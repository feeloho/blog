# 线性表部分代码实现

## 顺序表

```c
#include <stdio.h>
#define true 1
#define false 0
#define bool int

#define MAX_LENGTH 10

typedef int Elem;

typedef struct{
    int length;
    Elem *elem;
} List;

// 初始化
bool ListInit(List *l) {
    l->elem = (Elem *)malloc(MAX_LENGTH * sizeof(Elem));
    if (!l->elem) {
        return false;
    }

    l->length = 0;
    return true;
}

// 插入元素
bool ListInsert (List *l, int i, Elem e) {
    if (l->length >= MAX_LENGTH) {
        return false;
    }

    if (i < 1 || i > l->length+1) {
        return false;
    }

    for (int j=l->length; j>=i; j--) {
        l->elem[j] = l->elem[j-1];
    }

    l->length ++;
    l->elem[i-1] = e;
    return true;
}

// 删除元素
bool ListDelete(List *l, int i, Elem *e) {
    if (l->length < 1) {
        return false;
    }

    if (i < 1 || i > l->length) {
        return false;
    }

    *e = l->elem[i - 1];

    for (int j=i; j<l->length; j++) {
        l->elem[j-1] = l->elem[j];
    }

    l->length --;
    return true;
}

int main() {
    List l;
    ListInit(&l);

    for (int i=1; i<=10; i++) {
        printf("%d\n", ListInsert(&l, i, i));
    }

    Elem e;
    ListDelete(&l, 3, &e);
    printf("Deleted: %d\n", e);

    ListInsert(&l, 1, 99);

    for (int i=0; i<l.length; i++) {
        printf("%d ", l.elem[i]);
    }

    printf("\n");
    return 0;
}
```



## 链表

### 单链表

```c
#include <stdio.h>
#define true 1
#define false 0
#define bool int

typedef int Elem;

typedef struct {
    Elem elem;
    struct Node *next;
} Node;

// 头插法
Node *CreateListHead(int n) {
    Node *l = (Node *)malloc(sizeof(Node));
    l->next = NULL;

    Node *p;
    for (int i=0; i<n; i++) {
        p = (Node *)malloc(sizeof(Node));
        p->elem = i;
        p->next = l->next;
        l->next = p;
    }

    return l;
}

// 尾插法
Node *CreateListTail(int n) {
    Node *l = (Node *)malloc(sizeof(Node));

    Node *p, *t = l;
    for (int i=0; i<n; i++) {
        p = (Node *)malloc(sizeof(Node));
        p->elem = i;
        
        t->next = p;
        t = p;
    }

    t->next = NULL;
    return l;
}

// 插入
bool ListInsert(Node *l, int i, Elem e) {
    int j = 1;

    Node *n = l;
    while (j < i && n->next) {
        j ++;
        n = n->next;
    }

    if (j > i) {
        return false;
    }

    Node *t = (Node *)malloc(sizeof(Node));
    t->elem = e;
    t->next = n->next;
    n->next = t;

    return true;
}

// 删除
bool ListDelete(Node *l, int i, Elem *e) {
    int j = 1;
    
    Node *n = l;
    while (j < i && n->next) {
        j ++;
        n = n->next;
    }
    
    if (j > i) {
        return false;
    }

    Node *t = n->next;
    *e = t->elem;
    n->next = t->next;

    return true;
}

// 获取某个元素
bool GetElem(Node *l, int i, Elem *e) {
    int j = 1;

    Node *n = l;
    while (j < i && n->next) {
        j ++;
        n = n->next;
    }

    if (j > i) {
        return false;
    }

    *e = n->elem;
    return true;
}

int main() {
    Elem e;
    Node *l = CreateListTail(10);

    ListInsert(l, 5, 666);
    ListDelete(l, 10, &e);
    printf("%d\n", e);

    Node *p = l;
    while (p->next) {
        p = p->next;
        printf("%d ", p->elem);
    }

    GetElem(l, 3, &e);
    printf("\n%d", e);

    printf("\n");
    return 0;
}
```

### 静态链表

```c
#include <stdio.h>

#define true 1
#define false 0
#define bool int
#define MAX_SIZE 10

typedef int Elem;
typedef struct {
    int cur;
    Elem data;
} List[MAX_SIZE];

// 分配
int Malloc(List l) {
    int k = l[0].cur;
    if (k) {
        l[0].cur = l[k].cur;
    }

    return k;
}

// 回收
void Free(List l, int pos) {
    l[pos].cur = l[0].cur;
    l[0].cur = pos;
}

// 初始化
void InitList(List l) {
    for (int i=0; i<MAX_SIZE - 1; i++) {
        l[i].cur = i + 1;
        l[i].data = 0;
    }

    l[MAX_SIZE - 1].cur = 0;
}

// 长度
int ListLength(List l) {
    int j = 0;
    int i = l[0].cur;
    while (i) {
        i = l[i].cur;
        j ++;
    }

    return j - 1;
}

// 插入
bool ListInsert(List l, int pos, Elem elem) {
    if (pos < 1 || pos > ListLength(l) + 1) {
        return false;
    }

    int j = Malloc(l);
    if (!j) {
        return false;
    }

    l[j].data = elem;

    int i = MAX_SIZE - 1;
    for (int k=1; k<pos; k++) {
        i = l[i].cur;
    }

    l[j].cur = l[i].cur;
    l[i].cur = j;
    return true;
}

// 删除
bool ListDelete(List l, int pos) {
    if (pos < 1 || pos > ListLength(l)) {
        return false;
    }

    int j = l[MAX_SIZE - 1].cur;
    for (int i=1; i<pos-1; i++) {
        j = l[j].cur;
    }

    int k = l[j].cur;
    l[j].cur = l[k].cur;
    Free(l, k);

    return true;
}

void ListTraverse(List l) {
    int i = l[MAX_SIZE - 1].cur;

    while (i) {
        printf("%d: %d\n", i, l[i].data);
        i = l[i].cur;
    }
}

int main() {

    List l;
    InitList(l);

    ListInsert(l, 1, 11);
    ListInsert(l, 2, 3333);
    ListInsert(l, 2, 222);

    ListDelete(l, 2);

    ListInsert(l, 3, 44444);

    ListTraverse(l);
    printf("\n");

    for (int i=0; i<MAX_SIZE; i++) {
        printf("List[%d] { cur: %d \t data: %d }\n", i, l[i].cur, l[i].data);
    }

    return 0;
}
```

### 单向循环链表

```go
#include <stdio.h>
#define true 1
#define false 0
#define bool int

typedef int Elem;

typedef struct {
    Elem elem;
    struct Node *next;
} Node;

// 初始化
void InitList(Node **l) {
    *l = (Node *)malloc(sizeof(Node));
    (*l)->next = *l;
}

// 插入
bool ListInsert(Node *l, int i, Elem e) {
    if (i<1 || i > ListLength(l)+1) {
        return false;
    }

    Node *p = l;
    for (int j=1; j<i; j++) {
        p = p->next;
    }

    Node *n = (Node *)malloc(sizeof(Node));
    n->elem = e;
    n->next = p->next;

    p->next = n;
    return true;
}

// 删除
bool ListDelete(Node *l, int i) {
    if (i<1 || i>ListLength(l)) {
        return false;
    }

    Node *p = l;
    for (int j=1; j<i; j++) {
        p = p->next;
    }

    Node *n = p->next;
    p->next = n->next;
    return true;
}

// 长度
int ListLength(Node *l) {
    int i = 0;
    for (Node *p=l->next; p!=l; p=p->next) {
        i ++;
    }

    return i;
}

int main() {
    Node *l;

    InitList(&l);

    ListInsert(l, 1, 222);
    ListInsert(l, 1, 11);
    ListInsert(l, 3, 3333);
    ListDelete(l, 1);

    for (Node *n=l->next; n!=l; n=n->next) {
        printf("%d\n", n->elem);
    }

    printf("Length: %d\n", ListLength(l));
}
```

